Constructor Syntax and Semantics
================================

Status
  Draft

Author
  Tom Hildebrandt


Expands the syntax for a constructor to support an initializer list and
clarifies the semantics of field initialization.  


Abstract
--------

This Chapel Improvement Proposal records the last proposal for updated
constructor syntax and semantics.  This is the proposal that was presented at a
deep dive on 2014-12-09 with some changes based on feedback.

Status
------

This is a working document, recording the latest consensus of the Constructor
Subgroup.  Current contributors are: hilde, vass, mferguson, lydia

Revision History
++++++++++++++++

2015-06-23 Revision with comments from Vass and Michael.

2015-06-09 First version as a ChIP.

  Some time has passed since the December review.  This is my best
  recollection of the current proposal: Corrections, revisions and suggestions are
  welcome.

2014-12-09 Deep dive and group review

2012-06-?? hilde and vass complete a first draft


Rationale
---------

Several problems exist with the current implementation of class and record
initialization, which we term the "constructor story": no distinction is made
between initialization and assignment; the
semantics of method calls within constructors is not well-specified; and some
desirable behaviors exhibited by compiler-supplied constructors are not
available in user-supplied constructors.

Recent improvements in the automated memory management (AMM) implementation in
Chapel (a separate effort) forces a distinction between initialization and
assignment.  This new distinction causes the current implementation to be
modified in such a way that fields are first default-initialized and then
overwritten (though assignment) with the final value the constructor intends
them to have. [#]_  If this inefficiency is to be avoided, the syntax for
constructors must be augmented to allow field-initializations to be specified
explicitly.  Moreover, in some cases (for example if a field is declared to be
``const``) the behavior desired by the programmer cannot be obtained using the
existing syntax and semantics.  

Adding new field-initialization syntax supports a clarification of the
effect of ``const`` declarations, the degree to which dynamic dispatch is
supported in constructors and its associated semantics.
A further goal of this proposal is to clarify the semantics of
initialization for objects of derived types.  

Examples -- Existing Syntax and Semantics
+++++++++++++++++++++++++++++++++++++++++

Some programs compiled with the current implementation exhibit inconsistent or undesirable
behavior.  Some examples follow, accompanied by an explanation of why the
observed behavior differs from expectations.  To be fair, the expectations being
stated are part of the proposal, so agreeing with the proposal depends to a
large extent upon accepting those premises.

Example (Existing) -- Initialization by Assignment is Undesirable
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

An example of how a record constructor is currently written::

   record R {
     var i = 10;
     var r:real;
     var b:bool;

     proc R(s:real) {
       r = s;
     }
   }
   
   var t = new R(7.0);
   writeln(t);         // Prints: "(i = 10, r = 7.0, b = false)".


The above code declares a record of type ``R`` containing a constructor.  The constructor
accepts a real argument that is used to set the value of the ``r`` field.  Execution of
the declaration of ``t`` causes ``t`` to be associated with a record whose ``i`` field contains
the value "10", ``r`` field contains the value "7.0" and the ``b`` field is "false".  

In more detail, an unnamed temporary record is created and default-initialized as follows:  The ``i``
field receives the value "10", which is the field-default specified in the record
declaration; since no default value is specified for the ``r`` field, the type-default
value for type ``real`` "0.0" is used; similarly, the default value of ``bool`` "false"
is used to initialize field ``b``.  The body of the constructor is then entered.  The
value of field ``r`` is replaced by the value of ``s`` -- whatever value was passed as the
argument of the corresponding constructor call.  In this case, ``s`` is "7.0", so that is
the final value of the ``r`` field in the unnamed temporary.  The value of the
temporary is then bitwise-copied into the space reserved for ``t``.  

The problem with the above syntax is that the ``=`` in the body of the constructor must be
treated as assignment.  This is because there is no syntactical way to distinguish initializations
from assignment statements in that context.  

If ``s`` is to be assigned to ``r``, that
means that ``r`` must already have been initialized before the body of the constructor is
entered.  This means that all of the fields in an object must be initialized before the
body of one of its constructors is run.

In the current implementation, that is what happens: each field in a record or class being
constructed is first default-initialized; then, the statements in the body of the
constructor are executed.  Statements in the constructor body may then overwrite the
default field values with other values.

If the fields are of fairly simple types, then this default-initialization followed by
assignment is not so bad.  But when the types are complex or the assignment operator
expensive, then it adversely affects performance.  In addition, it may be
different from what the programmer intends.

For example, the semantics of initialization vs. assignment are very different
for ``sync`` and ``single`` variables.  Consider a record with a field of
``sync`` type.  By default, a single variable is initialized to ``(0, empty)``.
In the current implementation, an attempt to initialize the value of a sync
variable to anything other than its default value (using assignment) will also
cause its full-empty bit to transition to ``full``.  Although calls to primitive
functions could be used, the programmer does not have a convenient way to set
the contained value of a sync variable field within a constructor.

Arrays are another type whose initialization semantics are quite different from
its assignment semantics.  Assignment entails an element-by-element copy.
Therefore, default-initialization followed by assignment can be quite
expensive.  If the programmer can specify how an array is to be initialized
while avoiding expensive assignment operations, array initialization in an
application will become much cheaper (in terms of processor time).


The current proposal adds a field-initializer-clause to the syntax for a
constructor.  The field-initialization-clause allows field-initialization to be
expressed as initialization (not assignment).  Therefore, the semantics
expressed by a constructor no longer require each field to be
default-initialized and then updated through assignment.

Because initialization can and should be performed only once for each field,
fields that are initialized explicitly in the field-initializer-clause need not
be default-initialized.  The proposed syntax for field-initializers is
sufficiently expressive that in most cases a subsequent update (through
assignment) of the same field in the body of the constructor will not be
necessary.  However, this is still supported if the coder chooses to express
construction in that way.  This property also means that an implementation
supporting this proposal should support existing constructors in a
backward-compatible manner.


Example (Existing) -- Special Interpretation of ``const`` Required
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Given a record such as::

   record R {
     const i = 42;
   }

within the context of a constructor, it is currently permissible to update the
value of a field declared to be ``const``, as in::

   proc R.R(j:int) {
     i = j; // OK.
   }

whereas in any other method on an object of type ``R``, such an assignment is
illegal::

   proc R.foo(j: int) {
     i = j; // Illegal.
   }

One could argue that since constructors are "special", it is acceptable to have
special behavior associated with ``const`` fields when they are accessed in a
constructor.  

But this interpretation creates other problems.  Suppose that a constructor
calls a helper method that updates the const field.  A call to this method is
okay within the context of a constructor, but illegal elsewhere.  Since methods
that modify ``const`` fields cannot flagged as erroneous without reference to
their calling contexts, the compiler must initially accept them as valid.  Then
for each function resolved, the compiler must potentially examine the entire
call tree below it to determine if the ``const`` property of a field is being
violated.

In contrast, the present proposal would make it illegal to modify the value of a
const field in the body of *any* routine -- constructors included.  The
field-initializer syntax provides the means to establish the initial value of a
``const`` field.  Thereafter, the value of that field would be immutable.

To the extent that the proposal would make it easier to determine that an
update of a ``const`` field is invalid, it also makes it easier for a programmer
to reason about whether a particular call will be valid.


Example (Existing) -- Inconsistent Derived-Class Field Initialization
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The following code::

   class C {
     var x: int;
     proc myfunc() { x = 1; }
     proc C() { myfunc(); }
   }
   
   class SubC : C {
     proc myfunc() { x = 2; };
   }

   var myc = new C();
   writeln(myc);
   var mysubc = new SubC();
   writeln(mysubc);

is expected to produce::

   {x = 1}
   {x = 2}

or::

   {x = 1}
   {x = 1}

but instead outputs::

   {x = 1}
   {x = 0}

The rationale for the expected output is that the default initialization of an
object of type ``SubC`` should first perform default-initialization on its
base-class sub-object.  This would entail calling the zero-argument constructor
defined in ``class C``.  If the object being initialized has acquired its
dynamic type by that point in execution, then the call to myfunc() in the
constructor for ``C`` would dispatch to SubC.myfunc() and the value of its ``x``
field would be set to 2.  Otherwise, since the static type of the base-class
object is C, it would dispatch to C.myfunc().  In that case, the value of the
object's ``x`` field would be set to 1.  In no case should it be set to 0.

According to the current proposal, although dynamically-bound (polymorphic)
functions can be invoked in the body of a constructor, the dynamic type of an
object is not acquired until execution of is initializer list is complete.  That
means that initialization of the base-class sub-object will use the static type
of the base-class sub-object when dispatching to any methods called in the body of any of base-class
constructor.  That means that we will end up with the second behavior: Both base-
and derived-class objects will end up with their ``x`` fields initialized to 1.

Example (Existing) -- Record-Default Initialization Not Performed
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

When compiled with the current implementation, the following code::

   record R {
     var n: int;
     var A: [1..n] int;
   }
   var r = new R(5);
   writeln(r.A.domain);

prints out "1..5" as expected.  However, if the user adds the constructor::

   proc R.R(new_n: int) {
     n = new_n;
   }

then when the constructor is run, the field ``A`` is initialized using it
type-default value -- an empty array of ``int``.  In that case, the writeln prints
out an empty line.  The user might have expected ``A`` to instead be initialized
according to the record-default value.  This would result in the same behavior
as for the case when the constructor is missing.

The main problem here is that there is no way for the user to specify that he
wants to inherit the record-default initialization from the record declaration.

The current proposal solves this problem by stating that record-default
initialization is used unless the initialization of a field is explicitly
overridden in the initializer list.  This will provide behavior that is more
consistent with that of the current compiler-supplied all-fields constructor.


Examples -- Proposed Syntax and Semantics
+++++++++++++++++++++++++++++++++++++++++

Examples using the new syntax and semantics follow.  Each example shows how the
proposed syntax and semantics address the problems demonstrated by the examples
in the previous section.


Example (Proposed) -- Initialization by Assignment is Inefficient
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

If initialization by assignment is inefficient, the cure is to not use
assignment.  By providing explicit field-initialization syntax, the proposed
syntax allows the programmer to avoid that apparent inefficiency.

The above example, rewritten using the new syntax is::

   record R {
     var i = 10;
     var r:real;
     var b:bool;

     proc R(s:real)
     init (r = s)  // <- This is the new field-initialization clause.
     {}            // <- the constructor body is now empty.
   }

   var t = new R(7.0);
   writeln(r);         // Prints: "(i = 10, r = 7.0, b = false)".

The observable behavior of this example is the same as for the one above.  
However, this is due to the fact that initialization and assignment are
indistinguishable for fundamental types.  If field ``r`` were of a record type
whose assignment and copy operations differed, there would be an observable
difference between the two.

In the above (existing) example, the compiler inserts a call to
default-initialize ``r``, setting the value of ``r`` to the value returned by
``_defaultOf(r.type)``.  It then calls ``=(r, s)`` which invokes an assignment
operator that can bind ``r`` as its left operand and ``s`` as its right operand.
In contrast, the current example initializes ``r`` to the value of ``s`` by invoking
(as a method) a constructor of ``r.type`` than can bind to ``s`` as its argument.

Viewing the semantics of the constructor as a whole:

* Space for ``t`` is allocated.
* The constructor is then invoked on ``t`` as a method.  

  * It first executes the ``init`` clause.  This clause causes field ``t.r`` to
    be initialized using the value of ``s``.
  * After all explicit field initializations appearing in the ``init`` clause
    have been executed, the uninitialized fields in ``t`` are initialized in
    lexical order (according to the order in which they appear in the
    declaration of ``record R``).

    * The first such field is ``i``.  Since a field-default value of "10" is
      supplied, that value is used to initialize ``i``.
    * Since ``r`` has already been initialized, it is skipped.
    * Since there is no field-default value for ``b``, it is initialized using
      its type-default value "false".

  * Then, control is transferred to the body of the constructor, which in this case is empty.  

* Since ``t`` is initialized in-place, no bitwise copy is required after construction.


Example (Proposed) -- Special Interpretation of ``const`` Required
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

According to this proposal, fields declared to be ``const`` may be initialized
explicitly in the field-initializer-clause.  Otherwise, the class-or-record
default initializer expression is used, if present.  If not, then the
type-default value is used to initialize that field.  After the field is
initialized, it becomes immutable.

One of the above three initializations will be used by the time control reaches
the end of the field-initializer-clause in a constructor.  This means that in
the body of a constructor, fields declared to be ``const`` are immutable.
Therefore, the treatment of ``const`` fields is the same in the body of a
constructor as in the body of any other function.  Importantly, whether a field
is treated as mutable in a function or method is consistent, irrespective of
how it is called:  Namely, a ``const`` field is treated as immutable everywhere
outside of a field-initializer-clause.

The constructor as written in the corresponding example above now becomes illegal::

   proc R.R(j:int) {
     i = j; // Illegal -- cannot assign to i.
   }

The interpretation of this is that since the field-initializer-clause was
omitted from this constructor declaration, the field ``i`` is
default-initialized according to the class declaration (giving it a value of
42).  After it is initialized, it becomes immutable, so the attempt to overwrite
it with ``j`` fails (at compile time).

To get the desired behavior under the proposal, one would write::

   proc R.R(j:int)
   init (i = j)
   { }

This tells the compiler to initialize ``i`` by calling the constructor that is
effectively ``(i.type).(i.type)(j)``.  The body of the constructor is empty: the
value of ``i`` has been established and cannot be altered there.

The declaration of ``R.foo()`` above is still illegal, and now the compiler can
diagnose it as illegal without reference to whether it is called in the context
of a constructor.  This is true because (under this proposal) methods and
functions on cannot be invoked on an object before all of its fields have been
initialized.  This follows from the restriction that ``this`` cannot be
referenced explicitly or implicitly in the context of a field-initializer-clause.


Example (Proposed) -- Inconsistent Derived-Class Field Initialization
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Under this proposal, expected output of the above inheritance example is::

   {x = 1}
   {x = 1}

The reason for this is that the behavior of the compiler-supplied constructor
(called by _defaultOf()) for the derived class ``SubC`` is effectively::

   proc SubC.SubC()
   init (super = new C())
   { }

Execution proceeds by first initializing the base-class sub-object ``super`` (of
type C) by calling its zero-argument constructor directly.  (The
compiler-supplied version would instead call ``_defaultOf()``.)  This invocation
of ``proc C.C()`` initializes ``super`` by first default-initializing its field
``x`` to ``0`` and then calling ``myfunc()``.  Execution of ``myfunc()`` updates the
value of ``super.x`` to ``1`` (by assignment).  Control then returns to the body
of the constructor for ``SubC``, which is empty.

The reason why ``C.myfunc()`` is called to initialize the field ``x`` is that
``myfunc()`` is invoked in the body of the constructor for type ``C`` which is
called on the ``super`` sub-object of the ``SubC`` being constructed, not on the
``SubC`` as a whole.  Two things prevent this call to ``myfunc()`` from
dispatching dynamically to the object as a whole:

1. The layout of derived objects is left unspecified by this proposal, so it is
   not necessarily the case that the address of the base-class sub-object
   coincides with the address of the object as a whole, nor that the runtime
   type information of the two objects is shared.

2. Even if the runtime type information is shared, the object as a whole does
   not acquire the runtime type of the object as a whole (``SubC``) until after
   execution of the initializer list is complete.

In contrast, by the time the body of ``C.C()`` executes, the dynamic type of
``super`` has been set to ``C``.  It is therefore legal to invoke ``myfunc()``
in that context, and ``C.myfunc()`` is the version of ``myfunc()`` that will be
bound.

In conclusion, the value of ``SubC.x`` is set by the actions of the base-class
constructor that gets invoked, unless is it overridden explicitly (through
assignment) in the body of the derived class constructor.  If the field ``x`` is
to be overridden though initialization rather than though assignment, specific
provision must be made (by the base class author) in the constructor interface
of the base class.  This is not a disadvantage, since the notion of
encapsulation means that the base class has the final say on the ways in which
``x`` can be manipulated.

Similar reasoning applies to the interpretation of ``const`` fields owned by a
base class.  Either the base class will provide a constructor interface that
allows such ``const`` fields to be manipulated, or a derived class has no
control over them whatever, and must take them as they come.  Under this
proposal, the issue becomes a matter of the tradeoff between safety and utility
in the design of the base class -- not something that the language has to
address directly.

Example (Proposed) -- Record-Default Initialization Not Performed
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

The present proposal resolves the problem where default-initialization is not
performed in a consistent manner on fields whose initialization is unspecified.
In the current implementation: one behavior is observed (field-default
initialization is performed) when the compiler-supplied constructor is invoked;
another behavior is observed (field-default initialization is not performed) when
a user-defined constructor is supplied.

Under the present proposal, field-default initialization would be performed
uniformly.  In a user-defined constructor lacking field-initializer-clause (as
in the example), the compiler would effectively re-write it as::

   proc R.R(new_n: int)
   init (n, A)
   {
     n = new_n;
   }

This actually has the same behavior as the existing implementation.  In
contrast, the compiler-supplied default constructor would be implemented
as::

   proc R.R(new_n: int)
   init (n = new_n, A)
   { }

There isn't an exact representation of the current behavior (at least, not one
that is obvious to me), but the important part if this is that the field ``n``
gets initialized first, so that when ``A`` is initialized, the dimensions of its
domain can make use of ``n``.  

Under this proposal, the programmer can obtain the the desired behavior by
supplying an explicit initializer for field ``n`` in the
field-initializer-clause.  Since fields that are not mentioned explicitly are
initialized after those that are, this has the same effect as the above
facsimile of the compiler-supplied version::

   proc R.R(new_n: int)
   init (n = new_n)
   { }



Description
-----------

The proposal is to add field-initializer syntax and semantics to the Chapel
language.  It clarifies the order of initialization of fields -- including
initialization of base-class sub-objects -- and describes when ``const``
declarations (implying immutability) apply to the fields in an object and to the
object as a whole.

This proposal is a summary of the current state of the proposal based on
feedback on the previous proposal, presented to the group on a deep dive on
December 9 last year.  The previous proposal may be found in the source tree at
https://github.com/chapel-lang/chapel/spec/proposals/constructors.

For simplicity, this ChIP contains only the main proposal; support
for ``noinit`` initialization is handled in a separate ChIP [reference to be supplied].

The details of the proposal are given below, and restated briefly in the :ref:`summary` section.

.. _variables:

Variable Declaration Semantics
++++++++++++++++++++++++++++++

The syntax for variable declarations remains unchanged from the current specification.
However, the distinction between initialization and assignment offered in this proposal
requires a clarification of the *semantics* of variable initialization in light of that
distinction.

Given a declaration with an initializer::

   var r:R = <expr>;

The semantics of the current implementation are to first create and default-initialize the
variable ``r``.  The initialization expression is evaluated and its value copied into the
named variable ``r`` by assignment.  In the context of a variable declaration, ``=`` means
"assignment".  So the above declaration is exactly equivalent to::

   var r:R;    // r is default-initialized
   r = <expr>; // The value of <expr> is copied into r by assignment.

Here, we propose that in the context of a variable declaration, the ``=`` symbol be
treated as initialization instead.  That is, the above declaration statement should be
interpreted roughly as::

   pragma "noinit" var r:R; // Create space for r but don't initialize it.
   r.R(<expr>);             // Call a constructor on r.

This implementation does not use assignment.  Instead, it assumes the existence of a
constructor for type ``R`` that can bind to an argument of the type of ``<expr>``. [#]_
If the initialization expression is already of the same type as the variable (as, for
example, when the type of the variable is not stated explicitly), then copy-construction
will be used.

Under the proposal stated thus far, the syntax::

   var r = new R(<args>);

would imply that a temporary of type ``R`` is created and initialized by a call to
``R(<args>)``.  The resulting value would then be copied into ``r`` through
copy-construction.  (And finally, the temporary would be destroyed.)

We propose to take this a step further.  Since the constructor for the temporary
expression already operates on an object of type ``R`` it may as well operate on the
variable being declared.  In that special case, the temporary is not needed and one
copy-construction can be eliminated by invoking ``R(<args>)`` on ``r`` directly::

   pragma "noinit" var r:R; // Reserve some space for r.
   r.R(<args>);             // Initialize it by calling R(<args>).

This special case could be considered an optimization, but it isn't really:  It would have
observable effects within the program since it affects the number of times the
copy-constructor (or its equivalent) is called.  The recommendation is to leave
unspecified whether the copy-constructor is called in this case.

Considering that a temporary object is not constructed and no copy is performed,
the use of the keyword ``new`` in this context is somewhat misleading.  By
making it optional (for variables of record type only), we allow the programmer
to more closely express how initialization is actually performed.  Therefore,
the syntax::

   var r = R(<args>);

would be interpreted as "initialize ``r`` using a call to a constructor of
type ``R``, passing the given ``<args>``.


.. _syntax:

Constructor Declaration Syntax
++++++++++++++++++++++++++++++

In the current proposal, a constructor is introduced using the "C++" style: It
is a normal procedure declaration whose name matches the name of a (class or
record) type (the *subject type*) in scope at the point of declaration. [#]_  A
constructor may contain a field-initializer clause.  At present, the syntax for
a constructor is the same as for a procedure or method declaration, as given
by::

   procedure-declaration-statement:
     linkage-specifier[OPT] `proc' function-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT] function-body
   method-declaration-statement:
     linkage-specifier[OPT] proc-or-iter this-intent[OPT] type-binding function-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT] function-body

According to the proposal, the syntax would be augmented by the addition of an
optional field-initializer-clause::
  
   procedure-declaration-statement:
     linkage-specifier[OPT] `proc' function-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT] field-initializer-clause[OPT] function-body
   method-declaration-statement:
     linkage-specifier[OPT] proc-or-iter this-intent[OPT] type-binding function-name argument-list[OPT] return-intent[OPT] return-type[OPT] where-clause[OPT] field-initializer-clause[OPT] function-body

It is illegal for a non-constructor method to contain a
``field-initializer-clause``.  Because a special keyword is not used to
introduce a constructor, it is impossible to distinguish between normal
procedure declarations and constructor declarations (and respectively between
normal method declarations versus method constructor declarations) based on
syntax alone.  Parser production code or downstream processing must be employed
to enforce this constraint.

The rest of the required syntax is supplied by productions that render the
``field-initializer-clause`` in terms of previously-defined language elements
(consult the Syntax chapter in the `Chapel Specification <http://chapel.cray.com/spec/spec-0.97.pdf` for their definitions)::

   field-initializer-clause:
     `init' ( field-initializer-list )
     `init' = constructor-call-expression

   field-initializer-list:
     field-initializer
     field-initializer-list , field-initializer

   field-initializer:
     field-name = expression
     field-name
     variable-declaration
     = expression
     { expression }

   field-name:
     identifier

   constructor-call-expression:
     call-expression

In the first form of ``field-initializer-clause``, the ``init`` keyword is used
to introduce the list of field-initializers.  The list of field-initializers is
comma-separated and enclosed in parentheses.  Each field-name must name a
``var`` or ``const`` field in the base type of the constructor, or be
``super``.  

If a ``variable-declaration`` appears in
the ``field-initializer-list``, it creates a local variable.  A local variable can
be useful for capturing intermediate results, e.g. to initialize two different
fields to the same value -- the calculation of which is nontrivial.  If the
field-initializer does not contain a ``field-name`` and is not a
``variable-declaration`` (the fourth and/or fifth form), then the given expression is
evaluated for its side-effects.

In the second form of ``field-initializer-clause``, the ``init`` keyword is followed by an ``=`` followed by a
constructor call expression.  The name of constructor must match the name of the
subject type.  The second form allows one constructor to invoke another.  It
takes the place of a normal initializer list. [#]_

Generic Binding and Instantiation
+++++++++++++++++++++++++++++++++

The binding rules for a constructor and its arguments are the same as the
binding rules for a non-constructor method.  If a field-initializer names a
``param`` or ``type`` field in the constructor's type, then the initializer
expression is evaluated and used in determining the concrete type of the object
being constructed.  If a ``param`` or ``type`` field is named but no expression is provided in a
``field-initializer`` (the second form), then the class- or record-default for
that field is used, if provided.  Otherwise, it is a programming error.  (The
generic field in question remains unbound, so the type of the object is
indeterminate.)

After all generic fields are bound, the constructor is instantiated.  The
run-time semantics involve only the non-generic arguments and fields.  

.. _semantics:

Constructor Declaration Semantics
+++++++++++++++++++++++++++++++++

A constructor is a method on an object of the subject type.  When execution of a
constructor begins, the object (``this``) is in an uninitialized state (hence
all of its fields are also uninitialized).  Execution of the constructor
proceeds by first executing the ``field-initializer-clause`` and then executing the body of
the constructor.  

Execution of the ``field-initializer-clause`` proceeds by executing each of the
``field-initializer`` in lexical order.  In the form containing an ``=``, the
expression is evaluated and its value is used to initialize the corresponding
field in the object, as if by a constructor call.  These semantics are intended to be the
same as for initialization in the context of a variable declaration, as discussed above in
:ref:`variables`.  In the form containing just a
``field-name``, the field is initialized using the default-initializer supplied
in the field declaration, if present.  Otherwise, it is initialized using the
default value corresponding to its type.

The keyword ``super`` refers to the base-class sub-object.  The ``super`` field
behaves like any other field in the class. [#]_  The ``super`` field is
considered to precede all of the fields added in the derived type.  

A local variable behaves like a normal
variable declaration.  The variable introduced by a local variable declaration
in the field-initializer-clause remains in
scope until the end of the constructor body.

After all ``field-initializer`` expressions have
been processed, any fields in the object that remain uninitialized are
initialized in order of their appearance in the class or record declaration.
Each such initialization uses the value of ``initialization-part`` if present.
Otherwise, the field is initialized to the default value of the corresponding
type.  It is an error if neither a ``type-part`` nor an ``initialization-part``
is supplied in such declarations.

The expression appearing in a ``field-initializer`` may be arbitrarily complex.  It
may refer to global variables and to formal arguments in the constructor's
formal argument list.  However,
it is illegal for the expression in a ``field-initializer`` to refer to a value
that has not yet been initialized. [#]_ [#]_

The semantics of a constructor body are the same as the semantics of a method.
All fields of the subject type may be referred to implicitly, or explicitly
using ``this``.  Methods on ``this`` may be invoked using either explicit or
implicit syntax.  Because it is valid to call methods on ``this`` within the body of a
constructor, there is no reason to have a special ``initialize()`` function that is called
automatically if present.  The class designer can create arbitrarily-named initialization
helper functions -- even those taking arguments and returning values other than ``void``.
These must unfortunately be invoked explicitly, but that brings the advantage that those
initialization helpers become less hidden.


.. _inheritance:

Inheritance
+++++++++++

The syntax and semantics related to the ``super`` field are discussed above.
Mention of the ``super`` field in any user-defined class or record type is
always valid, since every class type derives from ``object`` and every record
type derives from ``value``.  

Since the subject type of a constructor is known at compile time, the type of
``super`` is also known at compile time (being the immediate base type of the
subject type).  Therefore, dispatches to ``super`` in a ``field-initializer-clause``
or constructor body need not be dispatched dynamically.  Likewise, in the body
of a constructor, the type of ``this`` is known at compile-time.  Therefore,
methods on this may be bound statically.

On the other hand, a constructor may arrange to pass ``this`` to a 
method while obscuring the static type of ``this`` by casting it to a base-class
type.  In that case, the method will be bound dynamically using the run-time
type of ``this``.  The dynamic type of ``this`` is established after processing
of the ``field-initializer-clause`` is complete, including the default
initialization of any fields not mentioned explicitly.  The dynamic type is set
equal to the subject type. [#]_


.. _const_ness:

Const-ness
++++++++++

A field declared to be ``const`` becomes immutable after it has been
initialized. [#]_  When a constructor is used to initialize an object that is
declared to be ``const``, the object as a whole (including any fields of
``this`` that are not declared to be ``const``) are mutable until
that constructor returns control to the caller.  Thereafter, the fields in that
object are all immutable.


.. _constructor_calls:

Constructor Calls
+++++++++++++++++

Given that an object being constructed should be in an uninitialized state, it should be
illegal to invoke a constructor on an object that has already been initialized.  According
to this proposal, the following code should generate a (compile-time) error::

   var r:R;     // Default-initialized, for example.
   ...
   r.R(<args>); // Illegal.

Constructor invocations involving ``new`` as described in the specification would still be
legal and retain the same semantics as are currently described there.  Invocation of a
constructor in the context of a variable initialization for field initialization will have the
semantics described above in :ref:`variables`.


.. _implementation:

Implementation Notes
++++++++++++++++++++

This proposal is primarily about the syntax and semantics of constructors --
approaching the subject from the user's perspective.  However, such a
description also influences how the requisite semantics are implemented.

In the above section on :ref:`semantics`, constructors are introduced as
methods.  That means that they have an implicit ``this`` variable that refers to
the object being constructed and they do not return a value.  This is consistent
with the semantics currently implemented.

The current implementation achieves these semantics in a somewhat roundabout
manner -- first creating an unnamed temporary object, initializing this by a
method call, and then transferring the contents of that object through a bitwise
copy into the space allocated for the named variable.

Although this proposal does not directly rely upon it, its recommendation is to
rework the implementation code so that constructor calls do, in fact, operate
like methods.  When that is done, the code::

   var t = new R(7.0);

will effectively be implemented as::

   pragma "noinit" var t; // Reserve some space for t on the stack.
   t.R(7.0);              // Call a constructor on t, passing 7.0 as an argument.

The basic change required in the implementation is to move the allocation
outside of what is currently a constructor function (not a method) and then
rework constructor functions to be methods instead.  

This change should have no effect at the behavioral level.  At the
meta-behavioral level (performance and resource usage), the difference should be
observable as faster execution and a smaller run-time memory footprint.  Some of
the implementation code should also be simpler.


.. _summary:

Summary
+++++++

The main syntactical and semantical provisions of this proposal are summarized as:

* Variable initialization should treat ``=`` as initialization (i.e. a constructor call),
  not as assignment.

* A ``field-initialization-clause`` will be added to the syntax for constructors.

  - The added syntax will consist of an introductory keyword followed by a list of
    initializer expressions enclosed in parentheses.  

  - Each initializer must bind to
    one of the fields declared in the constructor's object (class or record) type.

  - Each initializer provides a value to be used to initialize the corresponding
    field. 

  - The field being initialized must be named.  

  - The actual initialization order is
    the order of appearance of initializer list.  

  - Class- or record-default
    initializers will be used if the initializer list does not supply a value.

  - Default values may be used explicitly by naming the field without
    supplying a value.  

  - Local variables may be used to capture results in an
    initializer list.

  - An expression that does not bind to a field or local variable is evaluated
	for its side-effects.

  - A constructor call may be used place of a field initializer list.

* The fields and methods of ``this`` may be accessed within the body of a constructor.

* The special ``initialize()`` function is deprecated.

* Fields declared to be ``const`` become immutable after they have been
  initialized and before the body of the constructor is entered.  

* Objects declared
  to be ``const`` become immutable after the constructor has run to completion and
  control is returned to the point of invocation of the constructor.

* Direct invocation of a constructor (using method invocation syntax) should be illegal.


.. _open_issues:

Open Issues
+++++++++++

The following design points remain open for further discussion and resolution:

#. The idea of using keywords or well-known names to introduce constructors and
   destructors is helpful in generic programming.  It also serves to simplify
   scripts that are used to generate code automatically, since the constructor
   and destructor names do not have to track the class/record name.

   For reference, python uses well-known names for constructors (``__init__``),
   destructors (``__destroy__``) and other functions known to its object
   implementation.

   Noting that we already distinguish between iterators and procedures using the
   ``iter`` and ``proc`` keywords, it is in keeping with the current
   implementation to consider keywords for the constructor and destructor.
   However, if we go with the design of keeping separate the compiler entry
   points supporting memory management from user entry points, then the large
   number of names to be supported seems to favor using well-known names
   instead.

   Once the compiler entry points are documented, the implementation can be
   modified to treat those names specially.  Pragmas such as "auto copy fn" can
   be dropped from the user code, given that the parser can match those
   well-known names and apply the needed pragmas (flags) internally.

#. Should the MM interface used by the compiler be separate from the user
   interface?  This would mean that the user could write zero-argument
   constructors and constructors that can be called as copy constructors with
   the expectation that they would only be called if invoked explicitly (using
   ``new``).  The compiler-invoked equivalents would be the default initialization
   method (currently called ``_defaultOf`` and implemented as a function) and
   the copy-initialization method (currently called ``chpl__autoCopy`` and
   implemented as a function).  

   A type designer would be responsible for providing at least the
   compiler-invoked versions.  Whether the user-invoked versions are supplied is
   up to the type designer.  The compiler-invoked versions might be defined in
   terms of the user-invoked versions or vice versa.  Under the "no magic"
   principle, it is assumed that user code can invoke the compiler-invoked
   versions explicitly using their well-known names.

   For ease of programming, it is assumed that the compiler will supply default
   versions of the compiler-invoked MM functions.  There is no need to supply
   default versions of the user-invoked interfaces: whether they are provided is
   up to the type designer.

#. Should initialization of the base-class sub-object be treated like "just
   another field" or something else?  The basic requirement is to provide the
   author of a constructor control over how the fields in the base-class
   sub-object are initialized.  This is especially important when considering
   ``const`` fields in the base-class sub-object.

   The discussion may include the concept of direct access to fields in the base
   class by name, but should take into consideration the reality that access is
   effectively only through accessor methods, and that in future versions access
   control may be applied to these accessors.


.. rubric:: Footnotes

.. [#] This initialize-then-overwrite initialization is present in the existing
	   implementation for some initialization cases; it is just that AMM makes
	   it mandatory.

.. [#] If the concepts of coercion and construction are fused (as in C++) then argument
       coercion needs to be disabled in the context of a constructor call.  Otherwise,
       coercion chains could grow to arbitrary lengths, which is likely to lead to
       absurdities.

       If coercions are distinct from constructors, then it probably makes the most sense
       to use only copy-construction for initialization.  The initialization expression
       would need to be coercible to the target variable type.  It is unspecified whether
       copy-construction calls an actual constructor or is instead implemented as a
       bitwise copy followed by a call to a fixup (postblit) method.

.. [#] The idea of using a unique keyword such as ``ctor`` to introduce a
       constructor was discussed.  The keyword approach is useful for generic
       programming, because a constructor can be mentioned using a well-known
       name (such as ``__init__`` in Python).  The idea was abandoned for the
       sake of the current proposal because it did not obtain unanimous support.

.. [#] Any constructor for the subject type initializes all fields in an object
       of that type.  Since each field can be initialized only once, it would be
       illogical to include other field-initializers before or after a
       constructor call in a ``field-initializer-clause``.

.. [#] In particular, an initializer for ``super`` can appear anywhere in a
       ``field-initializer-clause`` or be omitted.  Once initialized, the fields
       of super may be referenced in other ``field-initializer`` expressions and
       methods of ``super`` may be invoked.  In this context, a reference to the
       ``super`` field is always explicit: it must be referred to using
       the name ``super``; it may not be referenced implicitly through ``this``.

.. [#] As a consequence, only the names of fields
       that precede the current ``field-initializer`` may appear
       anywhere in that ``field-initializer``'s expression.  In particular, the name of
       a field cannot appear in its own initializer expression.

.. [#] The object itself (``this``) is not fully initialized until after the
       initializer list has been processed in its entirety.  Therefore, it is illegal
       for the keyword ``this`` to appear anywhere in a ``field-initializer-clause``.
       In addition, implicit references to ``this`` (in the form of a method
       call that is intended to bind to ``this``) are illegal in the context of
       a field-initializer-clause.  (Implicit references to this are still
       supported within the body of a constructor.)

.. [#] In discussions, Vass expressed concerns about type-safety, given that any
       routine called from the initializer list or body of a constructor could
       publish the ``this`` object before it has been fully constructed.  There
       are three pieces that constitute this proposal's response to that
       concern:

       1. Since it is illegal to mention ``this`` in the initializer list, it
          cannot be published by any initialization expression appearing in the
          ``field-initializer-clause``.  The stricture against referring to ``this`` in
          that context also refers to implicit references.  That means that it is
          illegal to call a method of the subject type in the
          ``field-initializer-clause``, so ``this`` is prevented from escaping in
          that manner as well.
      
       2. The dynamic type of the object is not established until processing of the
          ``field-initializer-clause`` is complete.  It is not clear that the
          specification requires the base-class sub-object to be laid out in memory
          so that its starting address coincides with the starting address of the
          derived-class object.  It is also unclear whether the two share the same
          dynamic type field.  In the current implementation, they do not share the same
          starting address but they do share the same dynamic type field.
      
          The scenario of concern is if a base-class constructor attempts to
          publish the derived-class object before its initialization is complete.
          This would be accomplished through initialization of the ``super``
          field.  
      
          If the object being constructed shares its dynamic type field
          with the base-class sub-object, then within the body of the base class
          constructor the dynamic type of the ``super`` will be the type of the base class.
          An attempt to publish the object there will publish an
          object of base-class type.  Whether or not the object being constructed
          and the base-class object coincide in memory, only field accessors and
          methods applicable to the base type may be invoked: the compiler will not
          produce code that attempts in any way to access fields belonging uniquely
          (i.e. not through inheritance) to the object being constructed.  

          This remains true until the shared dynamic type field is updated after the
          object's ``field-initializer-clause`` is processed and before its body is
          entered.  If the base-class sub-object and the object itself do not coincide in
          memory, then the published object will still point to the base-class sub-object
          whose dynamic type has been updated to the derived-class object's type.  That
          would be bad; apparently our current implementation needs some re-thinking.  Of
          the four possibilities outlined above, ours is the only one guaranteed to fail.
          If the base-class sub-object and the object coincide and share their dynamic
          type field, then the object being constructed will exhibit behaviors associated
          with the derived type (i.e. the ability to access fields and invoke methods
          associated with that type) as soon as execution of its
          ``field-initializer-list`` is complete and before the body of its constructor
          has been entered.  
          If the base-class sub-object has its own type, then an object published
          by a base-class constructor will always be of the base type.  In that
          object layout scheme, there is no way to make a published ``this`` object
          exhibit dynamic type (polymorphic) behavior.
      
       3. Because it is considered to be fully-initialized at the beginning of a
          constructor body, the ``this`` object can be published anywhere in a
          constructor body.  The objection here might be that an object is not
          "blessed" as being fully constructed until the closing brace of the
          constructor is reached.
      
          A simple workaround is to require that any such publication be placed at
          the end of the constructor body.  A "virtual closing brace" exists at the
          point in the code at which all of the fields have values consistent with
          the invariants ascribed to a fully-constructed object of that class.
          Statements which appear after that virtual closing brace deal with the
          fully-constructed object, so it is OK for them to manipulate the object
          as a whole.  If the virtual closing brace does not exist, then the
          problem being addressed is a restatement of the Postman's Paradox.
      
          The stronger argument is that the point in the lifetime of the object at
          which it is safe to publish it is under the control of the class designer
          -- it is not a matter in which the language definition or the compiler
          can effectively or even desirably interfere.  It may be ready to publish
          at the very top of the constructor body -- subsequent changes being
          responded to dynamically by watchers on the published object.  It might
          not be ready to publish until several phases after its initial
          construction.  In which case, "avid" publication through the base-class
          constructor seems like a poor programming idiom.  All of this is best left to
          the class designer: aside from its effect on const-ness, there is nothing
          special about the closing brace of a constructor body.

.. [#] In particular, it cannot be modified in the body of the constructor.

