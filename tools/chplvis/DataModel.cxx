/*
 * Copyright 2015 Cray Inc.
 * Other additional copyright holders may be indicated within.
 *
 * The entirety of this work is licensed under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 *
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "DataModel.h"

// FLTK includes
#include <FL/fl_ask.H>

// C libraries

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

void DataModel::newList()
{
  //printf ("newList ...\n");
  curEvent = theEvents.begin();
  while (curEvent != theEvents.end()) {
    //Event *e = *curEvent;
    curEvent = theEvents.erase(curEvent);
    //if (e) delete e;
  }
}

int DataModel::LoadData(const char * filename)
{
  const char *suffix = strrchr(filename, '-');
  if (!suffix) {
    fl_message ("File %s does not appear to be generated by Chapel\n",
             filename);
    return 0;
  }
  suffix += 1;
  int namesize = strlen(filename) - strlen(suffix);
  // int fileno = atoi(suffix);

  // printf ("LoadData:  namesize is %d, fileno is %d\n", namesize, fileno);

  // printf ("loading data from %.*s* files ...", namesize, filename);

  // fflush(stdout);

  newList();
  curEvent = theEvents.begin();
  
  FILE *data = fopen(filename, "r");
  if (!data) {
    fl_message ("LoadData: Could not open %s.\n", filename);
    return 0;
  }

  // Read the config data
  char configline[100];

  if (fgets(configline, 100, data) != configline) {
    fl_message ("LoadData: Could not read file %s.\n", filename);
    fclose(data);
    return 0;
  }

  // The configuration data
  int nlocales;
  int fnum;
  double seq;

  int ssres = sscanf(configline, "ChplVdebug: nodes %d id %d seq %lf",
                      &nlocales, &fnum, &seq);
  if (ssres  != 3) {
    fl_message ("\n  LoadData: incorrect data on first line of %s. (%d)\n",
             filename, ssres);
    fclose(data);
    return 0;
  }
  fclose(data);

  char fname[namesize+15];
  // printf ("LoadData: nlocalse = %d, fnum = %d seq = %.3lf\n", nlocales, fnum, seq);

  // Set the number of locales.
  numLocales = nlocales;

  // Debug
  std::list<Event *>::iterator itr;
    
  for (int i = 0; i < nlocales; i++) {
    snprintf (fname, namesize+15, "%.*s%d", namesize, filename, i);
    if (!LoadFile(fname, i, seq)) {
      fl_message ("Error processing data from %s\n", fname);
      numLocales = -1;
      return 0;
    }
    // Debug
    /* 
    printf ("\nAfter file %s\n", fname);
    itr = theEvents.begin();
    while (itr != theEvents.end()) {
      (*itr)->print();
      itr++;
    }
    printf ("---------------\n");
    */
    
  }

  // printf (" done.\n");
  
  /*
  // Debug
  printf ("list has %ld items\n", (long)theEvents.size());
  itr = theEvents.begin();
  while (itr != theEvents.end()) {
    (*itr)->print();
    itr++;
  }

  // End debug
  */

  return 1;
}


// Load the data in the current file

int DataModel::LoadFile (const char *filename, int index, double seq)
{
  FILE *data = fopen(filename, "r");
  char line[1024];

  int floc;        // Number of locales in the file
  int findex;      // current locale's index
  double fseq;

  int  nErrs = 0;

  // Removing overhead ..
  // int ignoreFork = 0;
  // int ignoreTask = 0;

  if (!data) return 0;

  // printf ("LoadFile %s\n", filename);
  if (fgets(line,1024,data) != line) {
    fprintf (stderr, "Error reading file %s.\n", filename);
    return 0;
  }

  // Event times
  long e_sec, e_usec;

  // User/System time variables 
  long u_sec, u_usec, s_sec, s_usec;
  if (sscanf(line, "ChplVdebug: nodes %d id %d seq %lf %ld.%ld %ld.%ld %ld.%ld",
                     &floc, &findex, &fseq, &e_sec, &e_usec, &u_sec, &u_usec, &s_sec, &s_usec)
      != 9) {
    fprintf (stderr, "LoadData: incorrect data on first line of %s.\n",
             filename);
    fclose(data);
    return 0;
  }

  // Verify the data

  if (floc != numLocales || findex != index || fabs(seq-fseq) > .01 ) {
    printf ("Mismatch %d = %d, %d = %d, %.3lf = %.3lf\n", floc, numLocales, findex,
            index, fseq, seq);
    fprintf (stderr, "Data file %s does not match selected file.\n", filename);
    return 0;
  }

  // Create a start event with starting user/sys times.
  std::list<Event *>::iterator itr = theEvents.begin();

  // Other initializations
  numTags = 0;

  // Remove overhead ...
  //if (findex != 0) {
  //  ignoreFork = (findex*2+2<floc ? 2 : (findex*2+1<floc ? 1 : 0));
  //  ignoreTask = 3;
    // printf ("%s: overhead fork %d, task %d\n", filename, ignoreFork, ignoreTask );
  //}

  
  // Now read the rest of the file
  Event *newEvent = new E_start(e_sec, e_usec, findex, u_sec, u_usec, s_sec, s_usec);
  if (itr == theEvents.end()) {
    theEvents.push_front(newEvent);
  } else {
    // Move past existing start events
    while ((*itr)->Ekind() == Ev_start) { itr++; }
    theEvents.insert(itr,newEvent);
  }

  while ( fgets(line, 1024, data) == line ) {
    // Common Data
    char *linedata;
    long sec;
    long usec;
    long nextCh;

    // Data for tasks and comm and fork
    int nid;    // Node id
    int ntll;   // Node task list locale
    char nbstr[10];  // "begin" or "nb"
    int nlineno; // line number starting the task
    char nfilename[512];  // File name starting the task

    // comm
    int isGet;  // put (0), get (1)  currently ignoring non-block and strid
    int rnid;   // remote id
    long locAddr;  // local address
    long remAddr;  // remote address
    int eSize;     // element size
    int typeIx;    // type Index
    int dlen;      // data length 

    // fork
    int fid;

    // Tags
    int tagId;
    long nameOffset;  // Character offset for the tag name
    int slen;

    int cvt;

    // Process the line
    linedata = strchr(line, ':');
    if (linedata ) {
      if (sscanf (linedata, ": %ld.%ld%ln", &sec, &usec, &nextCh) != 2) {
        printf ("Can't read time from '%s'\n", linedata);
      }
    } else {
      nErrs++;
      continue;
    }

    newEvent = NULL;

    switch (line[0]) {

      case 0:  // Bug in output???
        nErrs++;
        break;

      case 't':  // new task line
        //  task: s.u nodeID task_list_locale begin/nb lineno filename
        if (sscanf (&linedata[nextCh], "%d %d %9s %d %511s",
                    &nid, &ntll, nbstr, &nlineno, nfilename) != 5) {
          fprintf (stderr, "Bad task line: %s\n", filename);
          fprintf (stderr, "nid = %d, ntll = %d, nbstr = '%s', nlineno = %d"
                   " nfilename = '%s'\n", nid, ntll, nbstr, nlineno, nfilename);
          nErrs++;
        } else {
          //int nfnLen = strlen(nfilename);
          //printf ("task line from %s\n", nfilename);
          //if (ignoreTask && nfnLen >= 34
          //    && (strcmp(&nfilename[nfnLen-34], "localeModels/flat/LocaleModel.chpl") == 0)) {
          //  ignoreTask--;
            //printf ("Found VisualDebug task line\n");
          //  break;
          // }
          newEvent = new E_task (sec, usec, ntll);
        }
        break;

      case 'e':  // end task (not generated yet)
        //printf ("z");
        break;

      case 'n':  // non-blocking put or get
      case 's':  // strid put or get
      case 'g':  // regular get
      case 'p':  // regular put
        // All comm data: 
        // s.u nodeID otherNode loc-addr rem-addr elemSize typeIndex len lineno filename
        if (sscanf (&linedata[nextCh], "%d %d 0x%lx 0x%lx %d %d %d %d %511s",
                    &nid, &rnid, &locAddr, &remAddr, &eSize, & typeIx, &dlen,
                    &nlineno, nfilename) != 9) {
          fprintf (stderr, "Bad comm line: %s\n", filename);
          nErrs++;
        } else {
          // Filter out modules/standard/VisualDebug.chpl (33 chars in length)
          int nfnLen = strlen(nfilename);
          if (nfnLen >= 33
              && (strcmp(&nfilename[nfnLen-33], "modules/standard/VisualDebug.chpl") == 0)) {
            //printf ("Found VisualDebug.chpl comm line\n");
            break;
          }
          isGet = (line[0] == 'g' ? 1 :
                   line[0] == 'p' ? 0 :
                   line[3] == 'g' ? 1 : 0);
          if (isGet)
            newEvent = new E_comm (sec, usec, rnid, nid, eSize, dlen, isGet);
          else
            newEvent = new E_comm (sec, usec, nid, rnid, eSize, dlen, isGet);
        }
        break;

      case 'f':  // All the forks:
        // s.u nodeID otherNode subloc fid arg arg_size
        if ((cvt = sscanf (&linedata[nextCh], "%d %d %d %*d 0x%*x %d", 
                           &nid, &rnid, &fid, &dlen)) != 4) {
          fprintf (stderr, "Bad fork line: (cvt %d) %s\n", cvt, filename);
          nErrs++;
        } else {
          //if (ignoreFork && (rnid == nid*2+1 || rnid == nid*2+2)) {
          //  ignoreFork--;
            // printf ("Ignoring fork: %s\n", linedata);
          //  break;
          // }
          newEvent = new E_fork(sec, usec, nid, rnid, dlen, line[1] == '_');
        }
        break;

      case 'P':  // Pause generating data
        if (sscanf (&linedata[nextCh], "%ld.%ld %ld.%ld %d %d",
                    &u_sec, &u_usec, &s_sec, &s_usec, &nid, &tagId) != 6 ) {
          fprintf (stderr, "Bad 'End' line: %s\n", filename);
          nErrs++;
        } else {
          newEvent = new E_pause(sec, usec, nid, u_sec, u_usec, s_sec, s_usec, tagId);
          //if (findex != 0) {
          //  ignoreFork = (findex*2+2<floc ? 2 : (findex*2+1<floc ? 1 : 0));
          //  ignoreTask = 2;
          //}
        }
        break;

      case 'T':  // Tag in the data
        slen = strlen(line)-1;
        if (line[slen] == '\n') line[slen] = 0;
        // printf ("TagLine: '%s'\n", &linedata[nextCh]);
        if (sscanf (&linedata[nextCh], "%ld.%ld %ld.%ld %d %d %ln",
                          &u_sec, &u_usec, &s_sec, &s_usec, &nid, &tagId, &nameOffset) != 6) {
          fprintf (stderr, "Bad 'Tag' line: %s\n", filename);
        } else {
          nextCh += nameOffset;
          newEvent = new E_tag(sec, usec, nid, u_sec, u_usec, s_sec, s_usec, tagId, 
                               &linedata[nextCh]);
          if (tagId >= numTags)
            numTags = tagId+1;
          //if (findex != 0) {
          //  ignoreFork = (findex*2+2<floc ? 2 : (findex*2+1<floc ? 1 : 0));
          //  ignoreTask = 2;
          //}
        }
        break;

      case 'E':  // end of the file
        if (sscanf (&linedata[nextCh], "%ld.%ld %ld.%ld %d",
                    &u_sec, &u_usec, &s_sec, &s_usec, &nid) != 5 ) {
          fprintf (stderr, "Bad 'End' line: %s\n", filename);
          nErrs++;
        } else {
          newEvent = new E_end(sec, usec, nid, u_sec, u_usec, s_sec, s_usec);
        }
        break;


      
      default:
        /* Do nothing */ ;
        //printf ("d");
    }
    //  Add the newEvent to the list, group Starts, Tags, Resumes and Ends together.
    if (newEvent) {
      if (theEvents.empty()) {
        theEvents.push_front (newEvent);
      } else if (itr == theEvents.end()) {
        theEvents.insert(itr, newEvent);
      } else {
        if (newEvent->Ekind() <= Ev_end) {
          // Group together
          while (itr != theEvents.end()
                 && (*itr)->Ekind() != newEvent->Ekind())
            itr++;
          if (itr == theEvents.end() || (*itr)->Ekind() != newEvent->Ekind()) {
            fprintf (stderr, "Internal error, event mismatch. file '%s'\n", filename); \
            printf ("newEvent: "); newEvent->print();
            if (itr != theEvents.end()) {
                printf ("itr: "); (*itr)->print();
            } else {
              printf ("At end of list\n");
            }
          } else {
            // More complicated ... move past proper kinds ...
            E_tag *tp = NULL;
            if (newEvent->Ekind() == Ev_start || newEvent->Ekind() == Ev_end) {
              // Just find the end of the group
              while (itr != theEvents.end() && (*itr)->Ekind() == newEvent->Ekind())
                itr++;
            } else {
              // Need to move past them only if they have the same tag!
              if (newEvent->Ekind() == Ev_tag) {
                // Work with tags
                tp = (E_tag *)newEvent;
                while (itr != theEvents.end()
                       && (*itr)->Ekind() == Ev_tag
                       && ((E_tag *)(*itr))->tagNo() == tp->tagNo())
                  itr++;
              } else {
                // Work with pauses
                E_pause *rp = (E_pause *)newEvent;
                while (itr != theEvents.end()
                       && (*itr)->Ekind() == Ev_pause
                       && ((E_pause *)(*itr))->tagId() == rp->tagId())
                  itr++;
              }
            }
            /*std::list<Event*>::iterator newElem = */ theEvents.insert (itr, newEvent);
            //      if (tp != NULL && tp->nodeId() == 0) {
            //        tagVec[tp->tagNo()-1] = newElem;
            //      }
          }
        } else {
          // Insert by time
          while (itr != theEvents.end() &&
                 (*itr)->Ekind() > Ev_end &&
                 **itr < *newEvent)
            itr++;
          theEvents.insert (itr, newEvent);
        }
      }
    }
  }

  if (nErrs) fprintf(stderr, "%d errors in data file '%s'.\n", nErrs, filename);

  //  if (ignoreFork > 0 || ignoreTask > 0) {
  //    fprintf (stderr, "%s: Error in data filters: ignoreFork = %d, ignoreTask = %d\n",
  //         filename, ignoreFork, ignoreTask);
  //  }
  
  if ( !feof(data) ) return 0;
  
  return 1;
}
