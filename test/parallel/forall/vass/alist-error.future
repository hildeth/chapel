bug: compiler crashes upon var Y = [x in ...] R.getNext().

The error is:

  internal error: Indexing list out of bounds [alist.cpp:69]


Workarounds:
* var R  -->  const R
* var Y = ...  -->  var Y: [this.X] real = ...
* replace R.getNext() with a literal (although this changes the behavior)


A smaller example that currently crashes in the same way is:

  proc main() {
    var X = 1..1;
    var R = 2;
    var Y = [x in X] R;
  }


Here is the investigation I did:


--- the stack trace at the error:

#0  printCallStackOnError () at misc.cpp:250
#1  0x00000000005b7d08 in handleError (fmt=0x5ba768 "Indexing list out of bounds") at misc.cpp:297
#2  0x0000000000405047 in AList::get (this=0x6f7dec8, index=2) at alist.cpp:69
#3  0x000000000049af03 in AggregateType::getField (this=0x6f7dd40, i=2) at type.cpp:1146
#4  0x00000000004849d6 in returnInfoGetMemberRef (call=0x259c4d0) at primitive.cpp:272
#5  0x000000000045abbc in CallExpr::typeInfo (this=0x259c4d0) at expr.cpp:3603
#6  0x00000000004cc7fe in isDef (se=0xf73720) at copyPropagation.cpp:295
#7  0x00000000004cd5bb in removeKilledSymbols (symExprs=std::vector of length 3, capacity 4 = {...}, available=std::map with 4 elements, ravailable=std::map with 2 elements, refs=std::map with 5 elements) at copyPropagation.cpp:690
#8  0x00000000004cd9d0 in localCopyPropagationCore (bb=0x150d510, available=std::map with 4 elements, ravailable=std::map with 2 elements, refs=std::map with 5 elements) at copyPropagation.cpp:824
#9  0x00000000004cdb37 in localCopyPropagation (fn=0x6f88910) at copyPropagation.cpp:849
#10 0x00000000005ad3d7 in lowerIterators () at lowerIterators.cpp:2163
#11 0x00000000004c569f in runPass (tracker=..., passIndex=19) at runpasses.cpp:198
#12 0x00000000004c55dd in runPasses (tracker=...) at runpasses.cpp:170
#13 0x00000000004c450d in main (argc=2, argv=0x7fffffffd778) at driver.cpp:977


--- the CallExpr in Frame 5:

(913550 CallExpr .
  (913551 SymExpr '_iterator[831604]:_ic__iterator_for_loopexpr4[831128]')
  (913552 SymExpr 2 '_literal_86[3775]:int(64)[77]'))

where

'type _ic__iterator_for_loopexpr4[831128]:_ic__iterator_for_loopexpr4[831128]'
    (831130 DefExpr 'super[831129]:object[218]')


--- In other words, the '.' primitive extracts 2nd field of a type
with just one field.


--- The '.' expr 913550 was created during
replaceIteratorFormalsWithIteratorFields():

#4  0x0000000000459ebf in CallExpr::CallExpr (this=0x259c4d0, prim=PRIM_GET_MEMBER, arg1=0x6f8dba0, arg2=0x91e480, arg3=0x0, arg4=0x0) at expr.cpp:3399
#5  0x00000000005a33da in replaceIteratorFormalsWithIteratorFields (iterator=0x6f7b110, ic=0x6f8dba0, asts=...) at lowerIterators.cpp:386
#6  0x00000000005a7fc6 in expandIteratorInline (forLoop=0x6f8e290) at lowerIterators.cpp:1198
#7  0x00000000005aa02f in expandForLoop (forLoop=0x6f8e290) at lowerIterators.cpp:1629
#8  0x00000000005ad317 in lowerIterators () at lowerIterators.cpp:2149
#9  0x00000000004c569f in runPass (tracker=..., passIndex=19) at runpasses.cpp:198
#10 0x00000000004c55dd in runPasses (tracker=...) at runpasses.cpp:170
#11 0x00000000004c450d in main (argc=2, argv=0x7fffffffd778) at driver.cpp:977

where 'iterator' is:

831040  fn _iterator_for_loopexpr4[831040]:_ir__iterator_for_loopexpr4[831133] 
831043  def arg iterator[831042]:DefaultAssociativeDom(int(64),true)[764127] 
884628  def arg R[884627]:_ref(RandomStream(true))[766730] 
831049  {
.......

It has two formals, so two fields are expected from the corresponding
_ic_ type. Dunno why the _ic_ type ends up without those.
